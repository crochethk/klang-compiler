/**
 * Basic command line parser. Use the argumentbuilder to configure options and flags.
 * When done call the {@code parse()} method, providing the {@code args} to parse.
 * The method will return a {@code CommandLineParser} instance providing access
 * to the parsed arguments using the keys defined in the first step.
 * 
 * This code is based on code generated by Claude.ai.
 */

package utils;

import java.util.*;

public class CommandLineParser {
    private final Map<String, Argument> argumentDefinitions;
    private final Map<String, String> parsedArguments;
    private final List<String> trailingArgs;
    private final boolean withTrailingArgs;

    private CommandLineParser(ArgumentBuilder builder, String[] args, boolean withTrailingArgs) {
        this.argumentDefinitions = builder.arguments;
        this.parsedArguments = new HashMap<>();
        this.trailingArgs = new ArrayList<>();
        this.withTrailingArgs = withTrailingArgs;
        parseAndValidate(args);
        applyDefaults();
    }

    public static record Argument(String name, boolean required, boolean hasValue, String defaultValue) {
    }

    public static class ArgumentBuilder {
        private final Map<String, Argument> arguments = new HashMap<>();
        private boolean withTrailingArgs = false;

        public ArgumentBuilder requiredArg(String name) {
            arguments.put(name, new Argument(name, true, true, null));
            return this;
        }

        public ArgumentBuilder optionalArg(String name) {
            arguments.put(name, new Argument(name, false, true, null));
            return this;
        }

        public ArgumentBuilder optionalArg(String name, String defaultValue) {
            arguments.put(name, new Argument(name, false, true, defaultValue));
            return this;
        }

        public ArgumentBuilder flag(String name) {
            arguments.put(name, new Argument(name, false, false, "false"));
            return this;
        }

        /** Require one or more unnamed trailing arguments. */
        public ArgumentBuilder withTrailingArgs() {
            this.withTrailingArgs = true;
            return this;
        }

        public CommandLineParser parse(String[] args) {
            return new CommandLineParser(this, args, withTrailingArgs);
        }
    }

    private void parseAndValidate(String[] args) {
        Set<String> providedRequiredArgs = new HashSet<>();
        boolean reachedTrailingArgs = false;

        for (int i = 0; i < args.length; i++) {
            String current = args[i];

            // Check if we've hit the trailing arguments delimiter
            if (current.equals("--")) {
                if (!withTrailingArgs) {
                    throw new IllegalArgumentException("No trailing arguments allowed");
                }

                // Add all remaining arguments as trailing args
                for (int j = i + 1; j < args.length; j++) {
                    trailingArgs.add(args[j]);
                }
                break;
            }

            // If we haven't started trailing args and this isn't a flag
            if (!current.startsWith("-")) {
                reachedTrailingArgs = true;
                if (!withTrailingArgs) {
                    throw new IllegalArgumentException("No trailing arguments allowed");
                }
                trailingArgs.add(current);
                continue;
            }

            // If we've started collecting trailing args, no more flags allowed
            if (reachedTrailingArgs) {
                throw new IllegalArgumentException("No flags allowed after trailing arguments");
            }

            String key = current.startsWith("--") ? current.substring(2) : current.substring(1);

            if (!argumentDefinitions.containsKey(key)) {
                throw new IllegalArgumentException("Unknown argument: " + current);
            }

            Argument argDef = argumentDefinitions.get(key);

            if (argDef.hasValue) {
                if (i + 1 >= args.length || args[i + 1].startsWith("-")) {
                    throw new IllegalArgumentException("Missing value for argument: " + current);
                }
                parsedArguments.put(key, args[i + 1]);
                i++; // Skip the value as we've consumed it
            } else {
                parsedArguments.put(key, "true");
            }

            if (argDef.required) {
                providedRequiredArgs.add(key);
            }
        }

        // Validate all required arguments were provided
        Set<String> missingArgs = new HashSet<>();
        for (Map.Entry<String, Argument> entry : argumentDefinitions.entrySet()) {
            if (entry.getValue().required && !providedRequiredArgs.contains(entry.getKey())) {
                missingArgs.add(entry.getKey());
            }
        }

        if (!missingArgs.isEmpty()) {
            throw new IllegalArgumentException(
                    "Missing required arguments: " + String.join(", ", missingArgs));
        }

        if (withTrailingArgs && trailingArgs.isEmpty()) {
            throw new IllegalArgumentException("Missing required trailing arguments");

        }
    }

    private void applyDefaults() {
        for (Map.Entry<String, Argument> entry : argumentDefinitions.entrySet()) {
            String key = entry.getKey();
            Argument arg = entry.getValue();

            if (!parsedArguments.containsKey(key) && arg.defaultValue != null) {
                parsedArguments.put(key, arg.defaultValue);
            }
        }
    }

    public String getValue(String argName) {
        if (!argumentDefinitions.containsKey(argName)) {
            throw new IllegalArgumentException("Argument not found: " + argName);
        }
        return parsedArguments.get(argName);
    }

    public boolean hasFlag(String flagName) {
        if (!argumentDefinitions.containsKey(flagName)) {
            throw new IllegalArgumentException("Flag not found: " + flagName);
        }
        String value = parsedArguments.get(flagName);
        return value != null && value.equals("true");
    }

    public List<String> getTrailingArgs() {
        return new ArrayList<>(trailingArgs);
    }

    public Map<String, String> getAllArguments() {
        return new HashMap<>(parsedArguments);
    }
}